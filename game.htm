<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>말씀 순서 맞추기 게임</title>
<style>

    * {
      box-sizing: border-box;
    }

    body {
      font-family: '맑은 고딕', sans-serif;
      background-color: #121212;
      color: #f0f0f0;
      margin: 0;
      padding: 5px 20px;
      overflow-x: hidden;
    }

    h2 {
      font-size: 1.6rem;
      text-align: left;
      color: #ffffff;
    }

    h3 {
      font-size: 1.4rem;
      text-align: left;
      color: #ffffff;
    }

    p {
     text-align: left;
      margin-bottom: 20px;
      font-size: 1rem;
    }

    #verse-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      padding: 20px;
      background-color: #1e1e1e;
      border: 2px dashed #888;
      border-radius: 12px;
      min-height: 100px;
    }

    .word {
      font-size: 1rem;
      padding: 8px 12px;
      background-color: #2c2c2c;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: grab;
      user-select: none;
      color: #f0f0f0;
      touch-action: none;
    }

    .word.dragging {
      opacity: 0.5;
    }
#bibleMemo,
#checkBtn {
  display: block;
  margin: 20px auto 10px auto;
  padding: 10px 0;     /* 위아래 패딩 크게 */
  font-size: 1.2rem;   /* 글자도 키움 */
  background-color: #444;
  color: #f0f0f0;
  border: none;
  border-radius: 12px; /* 모서리 약간 더 둥글게 */
  cursor: pointer;
  width: 100%;          /* 꽉 채우기 */

  box-sizing: border-box;
}
    #bibleMemo:hover,
    #checkBtn:hover {
      background-color: #666;
    }

    #result {
      margin-top: 20px;
      font-size: 1.2rem;
      font-weight: bold;
      text-align: center;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1000;
    }
/* 스타일에 추가 (checkBtn과 동일하게 적용) */
#restartBtn,
#mainBtn {
  display: block;
  margin: 10px auto 0 auto;
  padding: 10px 0;
  font-size: 1.2rem;
  background-color: #444;
  color: #f0f0f0;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  width: 100%;
  box-sizing: border-box;
}
#restartBtn:hover,
#mainBtn:hover {
  background-color: #666;
}

  #navButtons .navBtn {
  flex: 1;
  padding: 10px 0;
  font-size: 1rem;
  background-color: #444;
  color: #f0f0f0;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  width: 100%;
  box-sizing: border-box;
}
#navButtons .navBtn:hover {
  background-color: #666;
}  

  </style>
</head>
<body>
  <!-- 상단 네비게이션 버튼 -->
  <div id="navButtons" style="display:flex; gap:8px; margin-top:10px;">
    <button class="navBtn" onclick="goToFirst()"> 처음</button>
    <button class="navBtn" onclick="goToPrev()"> 이전</button>
    <button class="navBtn" onclick="goToNext()"> 다음</button>
    <button class="navBtn" onclick="goToLast()"> 마지막</button>
  </div>
  <h3 id="verseTitle" style=" margin-bottom:10px;">말씀 제목</h3>
  <p>단어를 드래그해서 순서대로 정렬하세요</p>

  <div id="verse-container"></div>

  <button id="checkBtn">✅ 정답 확인</button>
  <button id="restartBtn" style="display:none; margin-top:20px;">🔄 다시 시작하기</button>
  <button id="mainBtn">🏠 말씀암송 메인화면</button>
  <div id="result"></div>



  <script>
const STORAGE_KEY_VERSES = 'savedVerses2';
let verses = [];
let currentStage = 0;
let score = 0;

const verseTitle = document.getElementById('verseTitle');
const verseContainer = document.getElementById('verse-container');
const checkBtn = document.getElementById('checkBtn');
const result = document.getElementById('result');
const restartBtn = document.getElementById('restartBtn');

let draggedEl = null;
let offsetX = 0;
let offsetY = 0;

// 단어 드래그 요소 생성
function createWordDiv(word) {
  const div = document.createElement('div');
  div.className = 'word';
  div.textContent = word;
  enableCustomDrag(div);
  return div;
}

// 커스텀 드래그 기능 설정
function enableCustomDrag(el) {
  el.addEventListener('mousedown', dragStart);
  el.addEventListener('touchstart', dragStart, { passive: false });
}

function dragStart(e) {
  e.preventDefault();
  draggedEl = e.target;
  draggedEl.classList.add('dragging');

  const rect = draggedEl.getBoundingClientRect();
  const startX = e.touches ? e.touches[0].clientX : e.clientX;
  const startY = e.touches ? e.touches[0].clientY : e.clientY;

  offsetX = startX - rect.left;
  offsetY = startY - rect.top;

  document.addEventListener('mousemove', dragMove);
  document.addEventListener('touchmove', dragMove, { passive: false });
  document.addEventListener('mouseup', dragEnd);
  document.addEventListener('touchend', dragEnd);
}

function dragMove(e) {
  e.preventDefault();
  if (!draggedEl) return;

  const x = e.touches ? e.touches[0].clientX : e.clientX;
  const y = e.touches ? e.touches[0].clientY : e.clientY;

  draggedEl.style.position = 'fixed';
  draggedEl.style.left = `${x - offsetX}px`;
  draggedEl.style.top = `${y - offsetY}px`;
  draggedEl.style.zIndex = 1000;
  draggedEl.style.pointerEvents = 'none';
}

function dragEnd(e) {
  if (!draggedEl) return;

  const dropX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const dropY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

  const container = verseContainer;
  const allWords = [...container.querySelectorAll('.word:not(.dragging)')];

  let inserted = false;
  for (let word of allWords) {
    const rect = word.getBoundingClientRect();
    if (dropY < rect.bottom && dropX < rect.right) {
      container.insertBefore(draggedEl, word);
      inserted = true;
      break;
    }
  }

  if (!inserted) {
    container.appendChild(draggedEl);
  }

  draggedEl.classList.remove('dragging');
  draggedEl.style.position = '';
  draggedEl.style.left = '';
  draggedEl.style.top = '';
  draggedEl.style.zIndex = '';
  draggedEl.style.pointerEvents = '';
  draggedEl = null;

  document.removeEventListener('mousemove', dragMove);
  document.removeEventListener('touchmove', dragMove);
  document.removeEventListener('mouseup', dragEnd);
  document.removeEventListener('touchend', dragEnd);
}

// 로컬스토리지에서 데이터 불러오기
function loadVerses() {
  const saved = localStorage.getItem(STORAGE_KEY_VERSES);
  if (!saved) return null;
  try {
    return JSON.parse(saved);
  } catch {
    return null;
  }
}

// 현재 스테이지 UI 업데이트
function renderStage() {
  if (currentStage >= verses.length) {
    verseTitle.textContent = '🎉 모든 스테이지 완료!';
    verseContainer.innerHTML = '';
    checkBtn.style.display = 'none';
    result.textContent = `당신의 점수: ${score} / ${verses.length}`;
    restartBtn.style.display = 'block';
    return;
  }

  const verse = verses[currentStage];
  verseTitle.textContent = verse.title || `스테이지 ${currentStage + 1}`;
  const words = verse.text.trim().split(/\s+/);
  const shuffled = words.sort(() => Math.random() - 0.5);

  verseContainer.innerHTML = '';
  shuffled.forEach(word => {
    verseContainer.appendChild(createWordDiv(word));
  });

  result.textContent = '';
  checkBtn.style.display = 'block';
  restartBtn.style.display = 'none';
}

// 정답 확인 버튼 클릭 시
checkBtn.addEventListener('click', () => {
  const currentWords = [...verseContainer.querySelectorAll('.word')].map(el => el.textContent);
  const correctWords = verses[currentStage].text.trim().split(/\s+/);
  const isCorrect = JSON.stringify(currentWords) === JSON.stringify(correctWords);

  if (isCorrect) {
    score++;
    result.textContent = '🎉 정답입니다! 다음 스테이지로 넘어갑니다.';
    result.style.color = 'lightgreen';
    currentStage++;
    setTimeout(renderStage, 1500);
  } else {
    result.textContent = '❌ 아직 맞지 않았어요. 다시 시도해보세요!';
    result.style.color = 'orange';
  }
});

// 다시 시작 버튼 클릭 시
restartBtn.addEventListener('click', () => {
  currentStage = 0;
  score = 0;
  renderStage();
});

// 초기 실행
window.onload = () => {
  verses = loadVerses();
  if (!verses || verses.length === 0) {
    verseTitle.textContent = '데이터가 없습니다. bible.htm에서 먼저 저장해주세요.';
    checkBtn.style.display = 'none';
  } else {
    renderStage();
  }
};

// 메인화면 버튼 클릭 시 이동
document.getElementById('mainBtn').addEventListener('click', () => {
  window.location.href = 'bible.htm';
});
// 스테이지 네비게이션 함수
function goToFirst() {
  if (verses.length > 0) {
    currentStage = 0;
    renderStage();
  }
}

function goToPrev() {
  if (currentStage > 0) {
    currentStage--;
    renderStage();
  }
}

function goToNext() {
  if (currentStage < verses.length - 1) {
    currentStage++;
    renderStage();
  }
}

function goToLast() {
  if (verses.length > 0) {
    currentStage = verses.length - 1;
    renderStage();
  }
}
</script>

</body>
</html>
